target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import Line from "lib/Line.lf"

reactor LineAvoidanceRobot {
    preamble {=
        #include <math.h>
        #include <stdio.h>
    =}

    input detect: int   // 0 = none, 1 = left, 2 = center, 3 = right
    input init: bool

    output left_p: float 
    output right_p: float 

    logical action backup
    logical action turning

    state drive_power: float = 0.2
    state turn_power: float = 0.2

    state stored_direction: int = 0   // 1=left, 2=center, 3=right

    initial mode INIT {
        reaction(startup) -> left_p, right_p {=
            lf_set(left_p, 0.0f);
            lf_set(right_p, 0.0f);
        =}

        reaction(init) -> reset(DRIVING) {=
            lf_set_mode(DRIVING);
        =}
    }

    mode DRIVING {
        reaction(detect) -> reset(BACK_UP), left_p, right_p, backup {=
            if (detect->value != 0) {
                self->stored_direction = detect->value;
                // Schedule backing up
                lf_schedule(backup, 0);
                lf_set_mode(BACK_UP);
            } else {
                lf_set(left_p, self->drive_power);
                lf_set(right_p, self->drive_power);
            }
        =}
    }

    mode BACK_UP {
        reaction(backup) -> reset(TURN), left_p, right_p, turning {=
            // Reverse
            lf_set(left_p, -self->drive_power);
            lf_set(right_p, -self->drive_power);

            // Schedule turning after 800 ms
            lf_schedule(turning, MSEC(800));
            lf_set_mode(TURN);
        =}
    }

    mode TURN {
        reaction(turning) -> reset(DRIVING), left_p, right_p {=
            if (self->stored_direction == 1) {
                // line on left -> turn right
                lf_set(left_p,  self->turn_power);
                lf_set(right_p, -self->turn_power);
            } 
            else if (self->stored_direction == 3) {
                // line on right -> turn left
                lf_set(left_p, -self->turn_power);
                lf_set(right_p,  self->turn_power);
            }
            else if (self->stored_direction == 2) {
                // center -> turn (default to right)
                lf_set(left_p,  self->turn_power);
                lf_set(right_p, -self->turn_power);
            }

            // After turning duration, go back to driving
            lf_set_mode(DRIVING);
        =}
    }
}


main reactor (calibration_time: time = 5 s, sample_period: time = 100 ms) {
    preamble {=
        #include <stdio.h>
    =}

    display = new Display()
    motors  = new Motors()
    robot   = new LineAvoidanceRobot()
    line    = new Line()

    timer t(0, sample_period)
    timer seconds(0, 1 s)  // Timer used to display seconds.
    timer end_calibration(calibration_time)
    state count: int = 0
    state detected_direction: int = 0;

    // == Calibration ==
    reaction(startup) -> display.line0, display.line1, display.line2 {=
        lf_set(display.line0, "CALIBRATING");
        lf_set(display.line1, "Roll robot over");
        lf_set(display.line2, "light and dark.");
    =}

    // Display time elapsed
    reaction(seconds) -> display.line3 {=
        static char buf[17];
        snprintf(buf, 17, "time:%8d s", self->count++);
        lf_set(display.line3, buf);
    =}

    // End calibration
    reaction(end_calibration) -> line.calibrate, robot.init, robot.detect {=
        lf_set(line.calibrate, false);
        lf_set(robot.init, true);
        lf_set(robot.detect, 0);
    =}

    // == Read sensor: Trigger line sensor every t seconds ==
    reaction(t) -> line.trigger {=
        lf_set(line.trigger, true);
    =}

    reaction(line.reflect) -> robot.detect, display.line0, display.line1, display.line2 {=
        static int threshold = 750;
        static char buf0[17];
        static char buf1[17];
        static char buf2[17];
        bool left = (line.reflect->value[0] > threshold || line.reflect->value[1] > threshold);
        bool center = (line.reflect->value[1] > threshold || line.reflect->value[2] > threshold || line.reflect->value[3] > threshold);
        bool right = (line.reflect->value[3] > threshold || line.reflect->value[4] > threshold);
        
        snprintf(buf0, 17, "");
        snprintf(buf1, 17, "");
        snprintf(buf2, 17, "");
        self->detected_direction = 0;
        if (left) {
            snprintf(buf0, 17, "LEFT detected");
            self->detected_direction = 1;
        }
        if (center) {
            snprintf(buf1, 17, "CENTER detected");
            self->detected_direction = 2;
        }
        if (right) {
            snprintf(buf2, 17, "RIGHT detected");
            self->detected_direction = 3;
        }
        lf_set(robot.detect, self->detected_direction);
        lf_set(display.line0, buf0);
        lf_set(display.line1, buf1);
        lf_set(display.line2, buf2);
    =}

    robot.left_p  -> motors.left_power
    robot.right_p -> motors.right_power

}
